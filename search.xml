<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 动态代理</title>
    <url>/posts/java-dynamic-proxy.html</url>
    <content><![CDATA[<h2 id="一、代理：设计模式"><a href="#一、代理：设计模式" class="headerlink" title="一、代理：设计模式"></a>一、代理：设计模式</h2><p>代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。</p>
<p>代理模式中的角色：</p>
<ul>
<li>Subject（抽象主题角色）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；</li>
<li>RealSubject（真实主题角色）：真正实现业务逻辑的类；</li>
<li>Proxy（代理主题角色）：用来代理和封装真实主题；</li>
</ul>
<p>代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<h3 id="代理模式的好处"><a href="#代理模式的好处" class="headerlink" title="代理模式的好处"></a>代理模式的好处</h3><ul>
<li>隐藏委托类的实现，调用者只需要和代理类进行交互即可。</li>
<li>解耦，在不改变委托类代码情况下做一些额外处理，比如添加初始判断及其他公共操作<h3 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h3></li>
</ul>
<ol>
<li>在原方法执行之前和之后做一些操作，可以用代理来实现（比如记录Log，做事务控制等）。 </li>
<li>封装真实的主题类，将真实的业务逻辑隐藏，只暴露给调用者公共的主题接口。 </li>
<li>在延迟加载上的应用。</li>
</ol>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProxy</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HelloImpl helloService = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start HelloProxy"</span>);</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">        System.out.println(<span class="string">"end HelloProxy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello helloService = <span class="keyword">new</span> HelloProxy();</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h4><p>1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：</p>
<ul>
<li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大</li>
<li>新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类</li>
</ul>
<p>2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><h4 id="为什么需要动态代理？"><a href="#为什么需要动态代理？" class="headerlink" title="为什么需要动态代理？"></a>为什么需要动态代理？</h4><p>《设计模式》一书中给出的理由是“我们有时需要提供一个代理来控制对这个对象的访问”。</p>
<h5 id="为什么类可以动态生成？"><a href="#为什么类可以动态生成？" class="headerlink" title="为什么类可以动态生成？"></a>为什么类可以动态生成？</h5><p>Java虚拟机类加载过程主要分为五个阶段：加载、验证、准备、解析、初始化。其中加载阶段需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>由于虚拟机规范对这3点要求并不具体，所以实际的实现是非常灵活的，关于第1点，获取类的二进制字节流（class字节码）就有很多途径：</p>
<ul>
<li>从ZIP包获取，这是JAR、EAR、WAR等格式的基础</li>
<li>从网络中获取，典型的应用是 Applet</li>
<li>运行时计算生成，这种场景使用最多的是动态代理技术，在 java.lang.reflect.Proxy 类中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流</li>
<li>由其它文件生成，典型应用是JSP，即由JSP文件生成对应的Class类</li>
<li>从数据库中获取等等</li>
</ul>
<p>所以，动态代理就是想办法，根据接口或目标对象，计算出代理类的字节码，然后再加载到 JVM 中使用。<br>常见的字节码操作类库：</p>
<ul>
<li>Apache BCEL (Byte Code Engineering Library)：是Java classworking广泛使用的一种框架，它可以深入到JVM汇编语言进行类操作的细节。</li>
<li>ObjectWeb ASM：是一个Java字节码操作框架。它可以用于直接以二进制形式动态生成stub根类或其他代理类，或者在加载时动态修改类。</li>
<li>CGLib(Code Generation Library)：是一个功能强大，高性能和高质量的代码生成库，用于扩展JAVA类并在运行时实现接口。</li>
<li>Javassist：是Java的加载时反射系统，它是一个用于在Java中编辑字节码的类库; 它使Java程序能够在运行时定义新类，并在JVM加载之前修改类文件。</li>
</ul>
<p>实现动态代理的方式：</p>
<ul>
<li>通过实现接口的方式 -&gt; JDK 动态代理</li>
<li>通过继承类的方式 -&gt; CGLib 动态代理</li>
</ul>
<h2 id="二、JDK-动态代理"><a href="#二、JDK-动态代理" class="headerlink" title="二、JDK 动态代理"></a>二、JDK 动态代理</h2><p>JDK 动态代理的核心类有两个，InvocationHandler 和 Proxy。<br>InvocationHandler 是一个接口，只定义了 invoke 方法，表示方法的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，proxy 为代理类的实例，method 为被调用的方法对象，args 为方法参数。<br>Proxy 是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。<br>Proxy 类的主要方法为 newProxyInstance，该方法是 Java 为方便创建代理对象而封装的一个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 根据类加载器和接口创建代理类</span></span><br><span class="line">    Class clazz = Proxy.getProxyClass(loader, interfaces); </span><br><span class="line">    <span class="comment">//2. 获得代理类的带参数的构造函数</span></span><br><span class="line">    Constructor constructor = clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    <span class="comment">//3. 创建代理对象，并制定调用处理器实例为参数传入</span></span><br><span class="line">    Interface Proxy = (Interface)constructor.newInstance(<span class="keyword">new</span> Object[] &#123;handler&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 JDK 动态代理的步骤：</p>
<ol>
<li>实现 InvocationHandler 接口，创建调用处理器；</li>
<li>通过 Proxy 类指定 ClassLoader 对象和一组接口来创建动态代理类；</li>
<li>通过反射机制获得动态代理的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器作为参数被传入。</li>
</ol>
<p>下面通过一个具体的例子看看具体是如何使用的，：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//代理类持有一个委托类的对象引用  </span></span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloInvocationHandler</span><span class="params">(Object delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Enter method "</span>+method.getName());</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        Object result=method.invoke(delegate, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Exit method "</span> + method.getName());</span><br><span class="line">        System.out.println(<span class="string">"执行时间："</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> HelloInvocationHandler(hello);</span><br><span class="line">        IHello proxy = (IHello) Proxy.newProxyInstance(</span><br><span class="line">            hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JDK-动态代理的内部实现"><a href="#JDK-动态代理的内部实现" class="headerlink" title="JDK 动态代理的内部实现"></a>JDK 动态代理的内部实现</h4><p>JDK 动态代理用起来相对简单，那它内部具体是如何实现的呢？<br>首先我们来看，Proxy 类的静态方法 newProxyInstance。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用代理对象的构造方法</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成代理类的实例</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，关键步骤有三个：一是获取代理类，二是获取代理类的构造器，三是创建实例。<br>我们先来看一，获取代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">     proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">     <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">     <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">     <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">     <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>从 proxyClassCache 缓存中获取代理类，proxyClassCache 的类型为 WeakCache&lt;ClassLoader, Class<?>[], Class<?>&gt;，也就是从缓存中获取到的是 ProxyClassFactory。ProxyClassFactory 是 Proxy 类的内部类。<br>再来看 ProxyClassFactory 是如何运行的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">             * interface to the same Class object.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">             * interface.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>; <span class="comment">// package to define proxy class in</span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">         * proxy class will be defined in the same package. Verify that</span></span><br><span class="line"><span class="comment">         * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">             * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">             * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">             * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">             * exceeded).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProxyGenerator.generateProxyClass 是真正生成字节码的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">    ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">    <span class="keyword">if</span>(saveGeneratedFiles) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    <span class="keyword">if</span>(var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar), <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                        Files.createDirectories(var3, <span class="keyword">new</span> FileAttribute[<span class="number">0</span>]);</span><br><span class="line">                        var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        var2 = Paths.get(var0 + <span class="string">".class"</span>, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JDK-动态代理的优缺点"><a href="#JDK-动态代理的优缺点" class="headerlink" title="JDK 动态代理的优缺点"></a>JDK 动态代理的优缺点</h4><p>优点：</p>
<ol>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li>
<li>平滑进行 JDK 升级，而字节码类库通常需要进行更新以保证在新版 Java 能够使用。</li>
<li>代码实现简单。</li>
</ol>
<p>缺点：<br>因为 Java 单继承的限制（每个代理类已经继承了 Proxy 类），JDK 的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<h2 id="三、CGLib-动态代理"><a href="#三、CGLib-动态代理" class="headerlink" title="三、CGLib 动态代理"></a>三、CGLib 动态代理</h2><p>CGLib 采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。<br>使用 CGLib 代理的方法的步骤：</p>
<ol>
<li>实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</li>
<li>然后通过 CGLib 动态代理获取代理对象。</li>
</ol>
<p>还是使用 IHello 的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Enter method "</span>+method.getName());</span><br><span class="line">        <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(HelloImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> HelloInterceptor());</span><br><span class="line">        <span class="comment">// 2. 然后通过 CGLib 动态代理获取代理对象</span></span><br><span class="line">        HelloImpl hello = (HelloImpl) enhancer.create();</span><br><span class="line">        hello.sayHello()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CGLib-的内部实现"><a href="#CGLib-的内部实现" class="headerlink" title="CGLib 的内部实现"></a>CGLib 的内部实现</h4><p>使用 CGLib 代理之后的对象类型是 <code>cglib.HelloImpl$$EnhancerByCGLIB$$e3734e52</code>，这是 CGLib 动态生成的类型;<br>父类是 HelloImpl，印证了 CGLib 是通过继承实现代理；<br>同时实现了 net.sf.cglib.proxy.Factory 接口，这个接口是 CGLib 自己加入的，包含一些工具方法。</p>
<p>注意，既然是继承就不得不考虑final的问题，我们知道 final 类型不能有子类，所以 CGLib 不能代理final类型，遇到这种情况会抛出异常。<br>同样的，final方法是不能重载的，所以也不能通过 CGLib 代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CGLIB代理类具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConcrete</span>$$<span class="title">EnhancerByCGLIB</span>$$<span class="title">e3734e52</span> <span class="keyword">extends</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (tmp17_14 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将请求转发给MethodInterceptor.intercept()方法。</span></span><br><span class="line">            <span class="keyword">return</span> (String)tmp17_14.intercept(<span class="keyword">this</span>, </span><br><span class="line">                CGLIB$sayHello$<span class="number">0</span>$Method, </span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;&#125;, </span><br><span class="line">                CGLIB$sayHello$<span class="number">0</span>$Proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用代理对象的 sayHello() 方法时，首先会尝试转发给 MethodInterceptor.intercept() 方法，如果没有MethodInterceptor就执行父类的sayHello()。</p>
<h4 id="CGLib-动态代理的优缺点"><a href="#CGLib-动态代理的优缺点" class="headerlink" title="CGLib 动态代理的优缺点"></a>CGLib 动态代理的优缺点</h4><ol>
<li>不需要实现接口，从某种角度看，限定调用者实现接口时有些侵入性的实践。</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能。</li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="JDK-与-GBLib-性能对比"><a href="#JDK-与-GBLib-性能对比" class="headerlink" title="JDK 与 GBLib 性能对比"></a>JDK 与 GBLib 性能对比</h3><p>关于两者之间的性能的话，JDK动态代理所创建的代理对象，在以前的JDK版本中，性能并不是很高，虽然在高版本中JDK动态代理对象的性能得到了很大的提升，但是他也并不是适用于所有的场景。主要体现在如下的两个指标中：<br>1、CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；<br>2、但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距；<br>3、因此，对于单例的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用 CGLib 动态代理，反之，则比较适用JDK动态代理。</p>
<p>经过笔者实际测试，在1.6和1.7的时候，JDK动态代理的速度要比CGLib动态代理的速度要慢，但是并没有教科书上的10倍差距，在JDK1.8的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了。</p>
<h3 id="Python-实现动态代理"><a href="#Python-实现动态代理" class="headerlink" title="Python 实现动态代理"></a>Python 实现动态代理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, target)</span>:</span></span><br><span class="line">        self.target = target</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        target = object.__getattribute__(self, <span class="string">"target"</span>)</span><br><span class="line">        attr = object.__getattribute__(target, name)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">newAttr</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># 包装</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"before print"</span></span><br><span class="line">            res = attr(*args, **kwargs)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"after print"</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> newAttr</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealHello</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prints</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'hello'</span>, s</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = RealHello()</span><br><span class="line">    p = Proxy(t)</span><br><span class="line">    p.prints(<span class="string">"world"</span>)</span><br></pre></td></tr></table></figure>
<p>在 Python 里面类的属性(方法)都是一个对象，我们先拿到这个类方法对象attr，然后对这个类方法对象进行包装，再返回包装后的新方法对象newAttr。注意在获取target对象时，不能直接使用self.target，因为self.target会再次调用<strong>getattribute</strong>方法，这样就会导致死循环致堆栈过深曝出异常。取而代之应该使用object.<strong>getattribute</strong>方法来获取对象的属性值。</p>
<h3 id="Javaassist-动态代理"><a href="#Javaassist-动态代理" class="headerlink" title="Javaassist 动态代理"></a>Javaassist 动态代理</h3><p>Javaassist 是一种动态代理开源库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> javassist.util.proxy.MethodHandler;</span><br><span class="line"><span class="keyword">import</span> javassist.util.proxy.ProxyFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloDelegate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MethodHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDelegate</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object self, Method method, Method proceed, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before print"</span>);</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"after print"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealHello hello = enhanceHello(<span class="keyword">new</span> RealHello());</span><br><span class="line">        hello.say(<span class="string">"world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">enhanceHello</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        ProxyFactory proxy = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        proxy.setSuperclass(RealHello<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HelloDelegate&lt;T&gt; delegate = <span class="keyword">new</span> HelloDelegate&lt;T&gt;(target);</span><br><span class="line">            <span class="comment">// create方法传递了两个空数组</span></span><br><span class="line">            <span class="comment">// 分别代表构造器的参数类型数组和构造器的参数实例数组</span></span><br><span class="line">            <span class="keyword">return</span> (T) proxy.create(<span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>], delegate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaAssist 的 ProxyFactory 还提供了方法过滤器，它可以选择性地对特定方法进行增强。</p>
<h3 id="如何保存生成的代理类？"><a href="#如何保存生成的代理类？" class="headerlink" title="如何保存生成的代理类？"></a>如何保存生成的代理类？</h3><p>借助下面的工具类，把代理类保存下来再探个究竟。<br>或者通过设置环境变量sun.misc.ProxyGenerator.saveGeneratedFiles=true也可以保存代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下</span></span><br><span class="line"><span class="comment">     * params: clazz 需要生成动态代理类的类</span></span><br><span class="line"><span class="comment">     * proxyName: 为动态生成的代理类的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateClassFile</span><span class="params">(Class clazz, String proxyName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据类信息和提供的代理类名称，生成字节码</span></span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());</span><br><span class="line">        String paths = clazz.getResource(<span class="string">"."</span>).getPath();</span><br><span class="line">        System.out.println(paths);</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//保留到硬盘中</span></span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(paths + proxyName + <span class="string">".class"</span>);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argvs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存JDK动态代理生成的代理类，类名保存为 UserServiceProxy</span></span><br><span class="line">        ProxyUtils.generateClassFile(userServiceImpl.getClass(), <span class="string">"UserServiceProxy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEA 再次运行之后就可以在 target 的类路径下找到 UserServiceProxy.class，双击后IDEA的反编译插件会将该二进制class文件。<br>反编译出的大概如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m4 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"select"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"proxy.UserService"</span>).getMethod(<span class="string">"update"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zlbmd5dXpoZW5nZmFuL2FydGljbGUvZGV0YWlscy80OTU4NjI3Nw==">https://blog.csdn.net/fengyuzhengfan/article/details/49586277<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9iYTU0YjBmMjNjMTY=">https://www.jianshu.com/p/ba54b0f23c16<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzU0MzAxNw==">https://zhuanlan.zhihu.com/p/37543017<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly90b255YmFpLmNvbS8yMDA1LzAzLzI1L3Rob3VnaHRzLW9uLWR5bmFtaWMtcHJveHkv">https://tonybai.com/2005/03/25/thoughts-on-dynamic-proxy/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3czNzI0MjYwOTYvYXJ0aWNsZS9kZXRhaWxzLzgyNjIyNzYz">https://blog.csdn.net/w372426096/article/details/82622763<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS83NDg5">https://time.geekbang.org/column/article/7489<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82ZjZiYjJmMGVjZTk=">https://www.jianshu.com/p/6f6bb2f0ece9<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQ2FycGVudGVyTGVlL3AvODI0MTA0Mi5odG1s">https://www.cnblogs.com/CarpenterLee/p/8241042.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhb2x1bzUwMTM5NTM3Ny9wLzMzODMxMzAuaHRtbA==">https://www.cnblogs.com/xiaoluo501395377/p/3383130.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmVqajE5OTQvYXJ0aWNsZS9kZXRhaWxzLzc4MDgwMTI0">https://blog.csdn.net/lovejj1994/article/details/78080124<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWQzZTZiMzZmYjlhMDI4YmExZmVlNmE=">https://juejin.im/post/5ad3e6b36fb9a028ba1fee6a<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzFjYThkZjZmYjlhMDQ5YjM0N2Y1NWM=">https://juejin.im/post/5c1ca8df6fb9a049b347f55c<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2dpZ2l4LnRob3VnaHR3b3JrZXJzLm9yZy8yMDE4LzcvMjcvZHluYW1pYy1wcm94eS8=">http://gigix.thoughtworkers.org/2018/7/27/dynamic-proxy/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2NsaWZmbWV5ZXJzLmNvbS9ibG9nLzIwMDYvMTIvMjkvc3ByaW5nLWFvcC1jZ2xpYi1vci1qZGstZHluYW1pYy1wcm94aWVzLmh0bWw=">http://cliffmeyers.com/blog/2006/12/29/spring-aop-cglib-or-jdk-dynamic-proxies.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9qYXZhL2otbG8tcHJveHkxLw==">https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9yZWpveS5pdGV5ZS5jb20vYmxvZy8xNjI3NDA1">https://rejoy.iteye.com/blog/1627405<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kem9uZS5jb20vYXJ0aWNsZXMvY2dsaWItbWlzc2luZy1tYW51YWw=">https://dzone.com/articles/cglib-missing-manual<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NnbGliL2NnbGliL3dpa2kvSG93LVRvI2FjY2Vzcy10aGUtZ2VuZXJhdGVkLWJ5dGUtYXJyYXktZGlyZWN0bHk=">https://github.com/cglib/cglib/wiki/How-To#access-the-generated-byte-array-directly<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
</search>
